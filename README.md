# Базовый проект под К1986ВЕ92QI, Миландр

# Поддержка в SEGGER, FLM

# FLM_IntMem

Проект для сборки FLM для микроконтроллеров Миландр: https://github.com/glavmonter/FLM.

В алгоритмах реализовано стирание по секторам, которое на текущий момент отсутствует в FLM от производителя.
Стирание по секторам позволяет организовать прошивку МК через утилиту J-Flash, как это описано здесь -
https://startmilandr.ru/doku.php/prog:start:j-flash

*(Полностью стабильной работы с J-Flash добиться пока не удалось.)*

Статья по проекту: https://startmilandr.ru/doku.php/prog:start:newflm


### Назначение
* *1986VE1_FlashInt.FLM* - для 1986ВЕ1т и 1986ВЕ3Т, Cortex-M1.
* *1986VE9x_FlashInt.FLM* - для 1986ВЕ9х, Cortex-M3.

Версии 1986VE1_FlashIntDR.FLM и 1986VE9x_FlashIntDR.FLM используют повторное считывание значений при несовпадении валидируемых данных. Тесты для некоторых МК проходят только с этой опцией. Поэтому варианты с суффиксом DR (Double Read) на текущий момент считаются более надежными.

## Установка 

Копируем файлы из [FLM](FLM) в папку <SEGGER_JLINK_INSTALL_DIR>/Devices/Milandr/.  

В файл <SEGGER_JLINK_INSTALL_DIR>/JLinkDevices.xml дописать следующее:

```xml
    <Device>
        <ChipInfo Vendor="Milandr"
            Name="1986BE9X_DR"
            WorkRAMAddr="0x20000000"
            WorkRAMSize="0x8000"
            Core="JLINK_CORE_CORTEX_M3" />
        <FlashBankInfo Name="1986BE9X Flash"
            BaseAddr="0x8000000"
            MaxSize="0x20000"
            Loader="Devices\Milandr\1986VE9x_FlashInt_DR.FLM"
            LoaderType="FLASH_ALGO_TYPE_OPEN"
            AlwaysPresent="1" />
    </Device>
    <Device>
        <ChipInfo Vendor="Milandr"
            Name="1986BE9X"
            WorkRAMAddr="0x20000000"
            WorkRAMSize="0x8000"
            Core="JLINK_CORE_CORTEX_M3" />
        <FlashBankInfo Name="1986BE9X Flash"
            BaseAddr="0x8000000"
            MaxSize="0x20000"
            Loader="Devices\Milandr\1986VE9x_FlashInt.FLM"
            LoaderType="FLASH_ALGO_TYPE_OPEN" 
            AlwaysPresent="1" />
    </Device>
```

Для SEGGER JLink V6.88c можно скопировать [JLinkDevices.xml](FLM/JLinkDevices.xml) сразу в папку с установленным SEGGER.

При отладке и прошивке указывать `1986BE9X_DR` как конечный микроконтроллер, так устойчивее работает. 


# Release

## FreeRTOS v2.0.0

Релиз на FreeRTOS V10.4.1.

## MACS v1.0.0

Релиз на [ОСРВ МАКС](https://www.astrosoft.ru/products/development/rtos-macs/). Работает, надёжность неизвестна.

# Периферия представленная в проекте

## Простой вход

Вход сконфигурирован как "вход без триггера Шмитта". При переходе из 1 в 0 порог ~1.502 В, при обратном переходе 
порог 1,679 В, гистерезис 0,17 В. При включенном триггере: 1->0 при 1.466 В, 0->1 при 1,737 В, гистерезис 0,271 В.

## Компаратор

Вход + подключен к CVREF, внутренняя регулируемая опора. Вход - подключен на внешнюю ножку PE2. 

Режим без инвертирования: Если PE2 > CVREF (1.1 V), то As=0, Sy=0. При снижении напряжение на вход PE2 ниже порога CVREF
срабатывает прерывание компаратора и сигналы As=1, Sy=1. Сигнал Lch = 1 и считывается в прерывании. При подъёме напряжения
прерывание не срабатывает, но уровни As и Sy меняются на 0. При включении МК с порогом PE2 ниже, чем CVREF, то прерывание
генерируется. 

Режим с инвертированием: При PE2 > CVREF прерывание генерируется сразу Lch=1 (из прерывания), As=1, Sy=1. При снижении напряжение на 
входе PE2 ниже порога CVREF прерывание не генерируется, но биты As=0, Sy=0. При подъеме напряжения выше порога, 
генерируется прерывание Lch=1 (из прерывания), As=1, Sy=1.


## USB Device

USB Device Full Speed 48 Mbit, HID Class совместимый с SPD Client. Работа на прерываниях, передача строго по 64 байта.

## SSP Master, более известные как SPI

Направление выводов:

* Выход: FSS, CLK, TXD. OE_OUT, MODE_DIGITAL, SPEED_FAST
* Вход: RXD. OE_IN, MODE_DIGITAL, SPEED_FAST


Ведущий SSP (SPI), реализованный как на:

* вычитывание флагов [SSPPollTask.cpp](Core/src/SSPPollTask.cpp)
* обработке прерываний [SSPIrqTask.cpp](Core/src/SSPIrqTask.cpp)
* ПДП (DMA) [SSPDmaTask.cpp](Core/src/SSPDmaTask.cpp)

С ведомым проблем нет. Управлять FSS можно как программно (отдельный PORT), так и аппаратно. В аппаратном режиме
SSP опускается за полтакта до начала выдачи данных и поднимается через полтакта после окончания данных. Под данными 
понимается заранее сконфигурированный фрейм данных длиной от 4 до 16 бит. В SSP по одному FIFO на приём и передачу.
Глубина FIFO 8 ячеек по 16 бит. Ведущий SSP постоянно заполняет входной FIFO внешними данными. При передаче N кадров, в
приёмный FIFO поступит N кадров. Передачу и приём можно вести при любой комбинации SPH/SPO.

## SSP Slave, более известные как SPI

Направление выводов:

* Выход: TXD. OE_OUT, MODE_DIGITAL, SPEED_FAST
* Вход: FSS, CLK, RXD. OE_IN, MODE_DIGITAL, SPEED_FAST

Ведомый SSP имеет неприятную особенность.

В режиме SPH=0, работа по первому фронту CLK, принимаем только первое слово, после опускания FSS. Потоковая передача в 
режиме SPH=0 не возможна. Смотреть 26.6.16 и 26.6.18 Спецификации: 

`В режиме непрерывной передачи данных на линии SSP_FSS должны
формироваться импульсы высокого логического уровня между передачами каждого из
слов данных. Это связано с тем, что в режиме SPH=0 линия выбора ведомого устройства
в низком уровне блокирует запись в сдвиговый регистр. Поэтому ведущее устройство
должно переводить линию SSP_FSS в высокий уровень по окончании передачи каждого
кадра, разрешая, таким образом, запись новых данных.`

Потоковый приём реализуем только в режиме SPH=1, SPO=0/1. Пример в [SSPSlaveTask.cpp](Core/src/SSPSlaveTask.cpp).
В примере работа с внешним Ведущим на FT4222, FTDI. Реализована команда Whoiam как в НЧ драйвере на SPI шине.

## I2C Master

Ведущий I2C выполнен аппаратно, в микроконтроллере он только один. Блок I2C настраивается на скорость 100 кГц делителем
155 при тактовой 80 МГц, на скорость 400 кГц делителем 36. Пример в [IICMasterTask.cpp](Core/src/IICMasterTask.cpp).
В примере реализована запись и чтение внешней EEPROM типа M24M02, адрес ячейки: 2 бита в адресе + 2х8 в данных (18 бит).
Состояние START/STOP, адрес ведомого и 16 бит адреса ячейки передаётся с опросом флагов, а массив данных передаётся через кольцевой 
потокобезопасный буфер в прерывании от I2C.

I2C блок не имеет доступа к DMA.

## I2C Slave

Ведомый I2C реализован программно и занимает один таймер. Два канала таймера используются как детекторы обоих фронтов.
Реализация в [Middlewares/iicslave](Middlewares/iicslave) не самая оптимальная и выдерживает скорости до 120 кГц. 

Проверенные конфигурации каналов таймера:

| Каналы | Таймер | Выводы  | Результат |
|:------:|--------|---------|-----------|
|  1-2   | TIMER1 | PA1-PA3 | Успех     |
|  1-3   | TIMER1 | PA1-PA5 | Успех     |
|  1-4   | TIMER3 | PB0-PB7 | Успех     |
|  2-3   | TIMER1 | PA3-PA5 | Успех     |
|  2-4   | TIMER3 | PB2-PB7 | Успех     |
|  3-4   | TIMER3 | PB5-PB7 | Успех     |


### Цикл Записи

Адрес ведомого 0x37

![](PDF/IICsWrite.png)

S->Address_w->A->Register->ACK->DATA1->ACK->DATA2->ACK->DATAN->ACK->STOP

Первый байт данных (0x02) - адрес внутреннего регистра (Register). ACK выставляет Ведомый. Если регистра не существует, то можно 
будет ставить NACK. 

### Цикл Чтения

Адрес ведомого 0x37

![](PDF/IICsRead.png)

S->Address_w->A->Register->ACK->Sr->Address_r->DATA1->ACK->DATA2->DATAN->NACK

Первый байт данных (0x01) - адрес внутреннего регистра, из которого читаем. ACK при выборе регистра ставит Ведомый. 
Далее следует повторный START, Адрес Ведомого с битом на чтение и такты SCL. ACK на данных ставит Ведущий, последний 
байт данных завершается NACK, затем STOP.

### Сброс шины

Ведущий может задержать линию SDA в 0 и Ведущий теряет Арбитраж на шине. В таком случае необходимо оттактировать 9 клоков
на линию SCL. После 9 тактов шина Ведомый отпускает линию SDA, если не завис наглухо.

Пример на рисунке ![](PDF/IICsBusReset.png)


## Реакция на внешние прерывания

### Пропускаем вход через таймер, таймер дергает прерывание и через семафор пробрасывается в таск

| RTOS       | Optimization | Delay, us | Медленнее на | Размер прошивки | Больше на |
|------------|--------------|-----------|--------------|-----------------|-----------|
| MACS       | -Og          | 14.2      | 58,7%        | 10474           | 55.5%     |
| MACS       | -O1          | 13.4      | 53.7%        | 10314           | 55.4%     |
| MACS       | -O3          | 11.1      | 24.7%        | 11184           | 55.4%     |
| MACS       | -Os          | 16.0      | 75.8%        | 8942            | 44.1%     |
| MACS       | -Ofast       | 11.2      | 25.8%        | 11184           | 44.1%     |
| FreeRTOS   | -Og          | 8.95      |              | 6734            |           |
| FreeRTOS   | -O1          | 8.72      |              | 6638            |           |
| FreeRTOS   | -O3          | 8.90      |              | 7760            |           |
| FreeRTOS   | -Os          | 9.1       |              | 6206            |           |
| FreeRTOS   | -Ofast       | 8.9       |              | 7760            |           |
| Baremetal  |              | 1.6       |              |                 |           |


### Пропускаем вход через таймер, таймер дергает прерывание и через очередь пробрасывается в таск

| RTOS       | Optimization | Delay, us | Медленнее на |
|------------|--------------|-----------|--------------|
| MACS       | -Og          | 29.2      | 139%         |
| MACS       | -O1          | 28.2      | 137%         |
| MACS       | -O3          | 23.2      | 104%         |
| MACS       | -Os          | 31.9      | 163%         |
| MACS       | -Ofast       | 23.2      | 104%         |
| FreeRTOS   | -Og          | 12.2      |              |
| FreeRTOS   | -O1          | 11.9      |              |
| FreeRTOS   | -O3          | 11.4      |              |
| FreeRTOS   | -Os          | 12.1      |              |
| FreeRTOS   | -Ofast       | 11.4      |              |


### Пропускаем вход через таймер, таймер дергает прерывание и через Direct To Task Notifications в таск

| RTOS       | Optimization | Delay, us |
|------------|--------------|-----------|
| FreeRTOS   | -Og          | 9.2       |
| FreeRTOS   | -O1          | 9.0       |
| FreeRTOS   | -O3          | 8.7       |
| FreeRTOS   | -Os          | 8.9       |
| FreeRTOS   | -Ofast       | 8.8       |


# Применение SSP2 Master

| SSP      | Вывод | Направление | Примечание           |
|----------|-------|-------------|----------------------|
| SSP2_RXD | PD2   | Вход        | JTAG_B, 47k pull up  |
| SSP2_TXD | PD6   | Выход       | Свободный вывод      |
| SSP2_CLK | PD5   | Выход       | Свободный вывод      |
| SSP2_FSS | PD3   | Выход       | JTAG_B, 4.7k pull up |


# Настройка CLion

cidr.debugger.gdb.interrupt.signal = SIGTRAP, <https://youtrack.jetbrains.com/issue/CPP-21631>

# Декодер I2C EEPROM для DSView, Sigrok

Список поддерживаемых EEPROM для декодера пополнен на FM24CL64B и M24M02. Файл [Tools/lists.py](Tools/lists.py) 
скопировать в папку с установленным DSView: `decoders/eeprom24xx`.
